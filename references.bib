@techreport{Asanovic:ChipYard:2016,
    Author = {Asanović, Krste and Avizienis, Rimas and Bachrach, Jonathan and Beamer, Scott and Biancolin, David and Celio, Christopher and Cook, Henry and Dabbelt, Daniel and Hauser, John and Izraelevitz, Adam and Karandikar, Sagar and Keller, Ben and Kim, Donggyu and Koenig, John and Lee, Yunsup and Love, Eric and Maas, Martin and Magyar, Albert and Mao, Howard and Moreto, Miquel and Ou, Albert and Patterson, David A. and Richards, Brian and Schmidt, Colin and Twigg, Stephen and Vo, Huy and Waterman, Andrew},
    Title = {The Rocket Chip Generator},
    Institution = {EECS Department, University of California, Berkeley},
    Year = {2016},
    Month = {Apr},
    URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html},
    Number = {UCB/EECS-2016-17},
    Abstract = {Rocket Chip is an open-source Sysem-on-Chip design generator that emits synthesizable RTL. It leverages the Chisel hardware construction language to compose a library of sophisticated generators for cores, caches, and interconnects into an integrated SoC. Rocket Chip generates general-purpose processor cores that use the open RISC-V ISA, and provides both an in-order core generator (Rocket) and an out-of-order core generator (BOOM). For SoC designers interested in utilizing heterogeneous specialization for added efficiency gains, Rocket Chip supports the integration of custom accelerators in the form of instruction set extensions, coprocessors, or fully independent novel cores. Rocket Chip has been taped out (manufactured) eleven times, and yielded functional silicon prototypes capable of booting Linux.}
}

@inproceedings{Cook:Diplomatic:2017,
  title={Diplomatic design patterns: A {TileLink} case study},
  author={Cook, Henry and Terpstra, Wesley and Lee, Yunsup},
  booktitle={1st Workshop on Computer Architecture Research with RISC-V},
  pages={23},
  year={2017}
}

@inproceedings{Terpestra:TileLink:2017,
  title={{TileLink}: A free and open-source, high-performance scalable cache-coherent fabric designed for {RISC-V}},
  author={Terpstra, Wesley W},
  booktitle={Proceedings of the 7th RISC-V Workshop},
  year={2017}
}

@techreport{Waterman:Riscv:2011,
  title = {The RISC-V Instruction Set Manual, Volume I: Base User-Level {ISA}},
  author = {Waterman, Andrew and Lee, Yunsup and Patterson, David A. and Asanović, Krste},
  institution = {EECS Department, University of California, Berkeley},
  number = {UCB/EECS-2011-62},
  year = {2011},
  month = {May 13}
}

@inproceedings{Wei:FliT:2022,
author = {Wei, Yuanhao and Ben-David, Naama and Friedman, Michal and Blelloch, Guy E. and Petrank, Erez},
title = {{FliT}: A Library for Simple and Efficient Persistent Algorithms},
year = {2022},
isbn = {9781450392044},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503221.3508436},
doi = {10.1145/3503221.3508436},
abstract = {Non-volatile random access memory (NVRAM) offers byte-addressable persistence at speeds comparable to DRAM. However, with caches remaining volatile, automatic cache evictions can reorder updates to memory, potentially leaving persistent memory in an inconsistent state upon a system crash. Flush and fence instructions can be used to force ordering among updates, but are expensive. This has motivated significant work studying how to write correct and efficient persistent programs for NVRAM.In this paper, we present FliT, a C++ library that facilitates writing efficient persistent code. Using the library's default mode makes any linearizable data structure durable with minimal changes to the code. FliT avoids many redundant flush instructions by using a novel algorithm to track dirty cache lines. It also allows for extra optimizations, but achieves good performance even in its default setting.To describe the FliT library's capabilities and guarantees, we define a persistent programming interface, called the P-V Interface, which FliT implements. The P-V Interface captures the expected behavior of code in which some instructions' effects are persisted and some are not. We show that the interface captures the desired semantics of many practical algorithms in the literature.We apply the FliT library to four different persistent data structures, and show that across several workloads, persistence implementations, and data structure sizes, the FliT library always improves operation throughput, by at least 2.1X over a naive implementation in all but one workload.},
booktitle = {Proceedings of the 27th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {309–321},
numpages = {13},
keywords = {recoverability, non-volatile memory, concurrent data structures},
location = {Seoul, Republic of Korea},
series = {PPoPP '22}
}

@article{Zhao:SoniBboom:2020,
  title={SonicBOOM: The 3rd Generation Berkeley Out-of-Order Machine},
  author={Zhao, Jerry and Korpan, Ben and Gonzalez, Abraham and Asanovic, Krste},
  booktitle={Fourth Workshop on Computer Architecture Research with RISC-V},
  year={2020},
  month={May}
}

  

